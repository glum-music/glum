<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Glum</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* CRITICAL MOBILE FIX: Force fixed positioning to prevent address bar jumps */
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            overflow: hidden;
            background: #05070a; 
            touch-action: none;
        }
        
        /* CONTAINER LAYOUT */
        #canvas-wrapper {
            position: fixed; /* Locks it to screen, ignores scrolling */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #webgl-container { 
            width: 100%; 
            height: 100%; 
        }
        
        /* Logo: Centered */
        #logo-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2; 
            width: 70vw;
            max-width: 900px;
            pointer-events: none;
            opacity: 0.9;
        }
        
        #logo-overlay img {
            width: 100%;
            height: auto;
            display: block;
            mask-image: radial-gradient(circle, rgba(0,0,0,1) 40%, rgba(0,0,0,0) 100%);
            -webkit-mask-image: radial-gradient(circle, rgba(0,0,0,1) 40%, rgba(0,0,0,0) 100%);
            filter: drop-shadow(0 0 20px rgba(0,0,0,0.8)); 
        }

        #rain-canvas { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none; 
            mix-blend-mode: screen; 
            opacity: 0.4; 
        }
        
        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 4;
            pointer-events: none; 
            background: radial-gradient(circle, 
                rgba(0,0,0,0) 40%, 
                rgba(0,0,0,0.6) 80%, 
                rgba(0,0,0,0.95) 100%
            );
        }

        /* PLAYER STYLES */
        .glass-card {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.8);
        }
        
        input[type=range] {
            -webkit-appearance: none;
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 12px;
            width: 12px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -4px; 
            box-shadow: 0 0 10px rgba(255,165,0,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            border-radius: 999px;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="canvas-wrapper">
        <div id="webgl-container"></div>
    </div>
    
    <div id="logo-overlay">
        <img src="Glum.png" onerror="this.style.display='none'" alt="Band Logo">
    </div>

    <canvas id="rain-canvas"></canvas>
    <div id="vignette"></div>

    <div id="music-player" class="fixed bottom-6 right-6 z-50 w-80 max-w-[90vw] glass-card rounded-xl p-4 pointer-events-auto transition-opacity duration-500">
        <div class="flex items-center gap-3 mb-3">
            <div class="w-10 h-10 rounded bg-white/5 flex items-center justify-center text-orange-500 border border-white/10">
                <i data-lucide="music" class="w-5 h-5"></i>
            </div>
            <div class="flex-1 min-w-0">
                <div id="track-title" class="text-sm font-bold text-white truncate font-sans">
                    Loading...
                </div>
                <div class="text-[10px] text-orange-200/60 uppercase tracking-wider">
                    System Audio
                </div>
            </div>
        </div>

        <div class="mb-3 group relative">
            <input 
                type="range" 
                id="progress-bar"
                min="0" 
                max="100" 
                value="0" 
                class="w-full h-1 bg-white/10 rounded-lg appearance-none cursor-pointer"
            />
            <div id="progress-fill" class="absolute top-[6px] left-0 h-1 rounded-lg pointer-events-none bg-gradient-to-r from-orange-700 to-orange-500" style="width: 0%"></div>
        </div>

        <div class="flex items-center justify-between">
            <div class="flex items-center gap-2 w-24">
                <button id="mute-btn" class="text-gray-400 hover:text-white transition-colors">
                    <i id="vol-icon" data-lucide="volume-2" class="w-4 h-4"></i>
                </button>
                <div class="relative w-full h-4 flex items-center">
                    <input 
                        type="range" 
                        id="vol-bar"
                        min="0" 
                        max="1" 
                        step="0.05" 
                        value="0.5" 
                        class="relative z-10 w-full h-1 bg-white/10 rounded-lg appearance-none cursor-pointer"
                    />
                    <div id="vol-fill" class="absolute left-0 h-1 rounded-lg pointer-events-none bg-gradient-to-r from-orange-700 to-orange-500" style="width: 50%"></div>
                </div>
            </div>

            <div class="flex items-center gap-3">
                <button id="prev-btn" class="text-gray-400 hover:text-white transition-colors hover:scale-110 transform duration-200">
                    <i data-lucide="skip-back" class="w-5 h-5"></i>
                </button>
                <button id="play-btn" class="w-10 h-10 rounded-full bg-gradient-to-tr from-orange-700 to-orange-900 hover:from-orange-600 hover:to-orange-800 flex items-center justify-center text-white shadow-lg shadow-orange-900/40 transition-all hover:scale-110 hover:shadow-orange-500/20 border border-white/10">
                    <i id="play-icon" data-lucide="play" class="w-5 h-5 fill-current ml-0.5"></i>
                </button>
                <button id="next-btn" class="text-gray-400 hover:text-white transition-colors hover:scale-110 transform duration-200">
                    <i data-lucide="skip-forward" class="w-5 h-5"></i>
                </button>
            </div>
        </div>
    </div>

    <script id="vertex-shader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = vec4(position, 1.0);
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        // --- 1. ROBUST PRECISION HANDLING ---
        #ifdef GL_FRAGMENT_PRECISION_HIGH
            precision highp float;
        #else
            precision mediump float;
        #endif

        uniform float iGlobalTime;
        uniform vec2 iResolution;

        const float PI = 3.141592;
        #define EPSILON_NRM (0.1 / iResolution.x)

        // --- 2. MOBILE SPECIFIC SETTINGS (INJECTED VIA JS) ---
        #ifdef IS_MOBILE
            const int NUM_STEPS = 4;        // Minimal raymarch steps
            const int ITER_GEOMETRY = 2;    // Minimal wave detail
            const int ITER_FRAGMENT = 3;    // Minimal surface detail
        #else
            const int NUM_STEPS = 8;
            const int ITER_GEOMETRY = 3;
            const int ITER_FRAGMENT = 5;
        #endif
        
        const float SEA_HEIGHT = 0.6;
        const float SEA_CHOPPY = 4.0;
        const float SEA_SPEED = 0.8;
        const float SEA_FREQ = 0.16;
        const vec3 SEA_BASE = vec3(0.0, 0.01, 0.02); 
        const vec3 SEA_WATER_COLOR = vec3(0.1, 0.15, 0.25); 
        #define SEA_TIME (1.0 + iGlobalTime * SEA_SPEED)
        const mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);

        float hash( vec2 p ) {
            float h = dot(p,vec2(127.1,311.7));
            return fract(sin(h)*43758.5453123);
        }

        float noise( in vec2 p ) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            vec2 u = f*f*(3.0-2.0*f);
            return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), hash( i + vec2(1.0,0.0) ), u.x),
                                mix( hash( i + vec2(0.0,1.0) ), hash( i + vec2(1.0,1.0) ), u.x),
                                u.y);
        }

        float diffuse(vec3 n,vec3 l,float p) {
            return pow(max(dot(n,l) * 0.4 + 0.6, 0.0), p);
        }
        
        float specular(vec3 n,vec3 l,vec3 e,float s) {
            float nrm = (s + 8.0) / (PI * 8.0);
            return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;
        }

        vec3 getSkyColor(vec3 e) {
            e.y = max(e.y,0.001); // Safe clamp
            vec3 darkSky = vec3(0.01, 0.01, 0.03);
            vec3 horizon = vec3(0.04, 0.06, 0.12); 
            return mix(horizon, darkSky, pow(e.y, 0.6));
        }

        float sea_octave(vec2 uv, float choppy) {
            uv += noise(uv);        
            vec2 wv = 1.0-abs(sin(uv));
            vec2 swv = abs(cos(uv));    
            wv = mix(wv,swv,wv);
            
            // --- 3. SAFE MATH FOR MOBILE ---
            // On mobile, complex pow() chains often return NaN (Black Screen).
            // We simplify the math if IS_MOBILE is set.
            #ifdef IS_MOBILE
                return pow(max(1.0 - wv.x * wv.y, 0.0), choppy);
            #else
                return pow(max(1.0 - pow(wv.x * wv.y, 0.65), 0.0), choppy);
            #endif
        }

        float map(vec3 p) {
            float freq = SEA_FREQ;
            float amp = SEA_HEIGHT;
            float choppy = SEA_CHOPPY;
            vec2 uv = p.xz; uv.x *= 0.75;
            
            float d, h = 0.0;    
            for(int i = 0; i < ITER_GEOMETRY; i++) {        
                d = sea_octave((uv+SEA_TIME)*freq,choppy);
                d += sea_octave((uv-SEA_TIME)*freq,choppy);
                h += d * amp;        
                uv *= octave_m; freq *= 1.9; amp *= 0.22;
                choppy = mix(choppy,1.0,0.2);
            }
            return p.y - h;
        }

        float map_detailed(vec3 p) {
            float freq = SEA_FREQ;
            float amp = SEA_HEIGHT;
            float choppy = SEA_CHOPPY;
            vec2 uv = p.xz; uv.x *= 0.75;
            
            float d, h = 0.0;    
            for(int i = 0; i < ITER_FRAGMENT; i++) {        
                d = sea_octave((uv+SEA_TIME)*freq,choppy);
                d += sea_octave((uv-SEA_TIME)*freq,choppy);
                h += d * amp;        
                uv *= octave_m; freq *= 1.9; amp *= 0.22;
                choppy = mix(choppy,1.0,0.2);
            }
            return p.y - h;
        }

        vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  
            float fresnel = 1.0 - max(dot(n,-eye),0.0);
            fresnel = pow(fresnel,3.0) * 0.5;
            
            vec3 reflected = getSkyColor(reflect(eye,n));    
            vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; 
            
            vec3 color = mix(refracted,reflected,fresnel);
            
            float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);
            color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;
            
            float spec = specular(n,l,eye,60.0);
            color += vec3(spec) * 0.5; 
            
            return color;
        }

        vec3 getNormal(vec3 p, float eps) {
            vec3 n;
            n.y = map_detailed(p);    
            n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;
            n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;
            n.y = eps;
            return normalize(n);
        }

        float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  
            float tm = 0.0;
            float tx = 1000.0;    
            float hx = map(ori + dir * tx);
            if(hx > 0.0) return tx;   
            float hm = map(ori + dir * tm);    
            float tmid = 0.0;
            for(int i = 0; i < NUM_STEPS; i++) {
                tmid = mix(tm,tx, hm/(hm-hx));                    
                p = ori + dir * tmid;                     
                float hmid = map(p);
                if(hmid < 0.0) {
                    tx = tmid;
                    hx = hmid;
                } else {
                    tm = tmid;
                    hm = hmid;
                }
            }
            return tmid;
        }

        void main() {
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            uv = uv * 2.0 - 1.0;
            
            float aspect = iResolution.x / iResolution.y;
            uv.x *= aspect; 
            
            // --- 4. CAMERA ADJUSTMENT FOR MOBILE ---
            float camHeight = 3.5;
            #ifdef IS_MOBILE
                uv *= 1.5;      // Wider angle
                camHeight = 5.0; // Higher up
            #endif

            float time = iGlobalTime * 0.3;
                
            vec3 ori = vec3(0.0, camHeight, time*5.0);
            vec3 dir = normalize(vec3(uv.xy, -2.0)); 
            dir.z += length(uv) * 0.15;
            dir = normalize(dir);
            
            vec3 p;
            heightMapTracing(ori,dir,p);
            vec3 dist = p - ori;
            vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);
            
            vec3 light = normalize(vec3(0.0, 1.0, 0.8)); 
            
            vec3 color = mix(
                getSkyColor(dir),
                getSeaColor(p,n,light,dir,dist),
                pow(smoothstep(0.0,-0.05,dir.y),0.3)
            );
            
            // Final safety clamp
            color = max(color, 0.0);
            
            gl_FragColor = vec4(pow(color,vec3(0.8)), 1.0);
        }
    </script>

    <script>
        // --- DETECT MOBILE ---
        // We use a robust detection to enable "Safe Mode"
        const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
        
        console.log("Is Mobile Mode:", isMobile);

        const container = document.getElementById('webgl-container');
        
        // --- THREE.JS SETUP ---
        const renderer = new THREE.WebGLRenderer({ 
            antialias: !isMobile, // Disable antialias on mobile for performance
            alpha: false,
            powerPreference: "high-performance"
        });
        
        // Cap pixel ratio at 2.0
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = false; 
        renderer.autoClear = false;
        container.appendChild(renderer.domElement);

        const sceneBG = new THREE.Scene();
        const cameraBG = new THREE.Camera();
        const geometryBG = new THREE.PlaneBufferGeometry(2, 2);
        
        const uniformsBG = {
            iGlobalTime: { value: 0 },
            iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
        };

        // --- INJECT SHADER DEFINES ---
        let fragCode = document.getElementById('fragment-shader').textContent;
        if(isMobile) {
            // Inject the IS_MOBILE definition at the very top of the shader
            fragCode = "#define IS_MOBILE\n" + fragCode;
        }

        const materialBG = new THREE.ShaderMaterial({
            uniforms: uniformsBG,
            vertexShader: document.getElementById('vertex-shader').textContent,
            fragmentShader: fragCode,
            depthWrite: false
        });
        sceneBG.add(new THREE.Mesh(geometryBG, materialBG));

        const scene3D = new THREE.Scene();
        const camera3D = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // --- SCENE LIGHTING ---
        // (Kept simple for performance)
        const moonLight = new THREE.DirectionalLight(0x667799, 0.25); 
        moonLight.position.set(-10, 20, -10);
        scene3D.add(moonLight);

        const lanternLight = new THREE.PointLight(0xff5500, 1.0, 20); 
        lanternLight.position.set(0, 5, 2);
        scene3D.add(lanternLight);

        // --- RAIN CANVAS ---
        const canvas = document.getElementById('rain-canvas');
        const ctx = canvas.getContext('2d');
        
        let w = window.innerWidth;
        let h = window.innerHeight;
        canvas.width = w;
        canvas.height = h;

        const drops = [];
        const rainCount = isMobile ? 100 : 300; // Less rain on mobile

        class Drop {
            constructor() { this.reset(); }
            reset() {
                this.x = Math.random() * w;
                this.y = Math.random() * -h;
                this.speed = Math.random() * 10 + 15; 
                this.len = Math.random() * 15 + 10;
                this.opacity = Math.random() * 0.2 + 0.05;
            }
            update() {
                this.y += this.speed;
                if (this.y > h) this.reset();
            }
            draw() {
                ctx.beginPath();
                ctx.strokeStyle = `rgba(200, 210, 255, ${this.opacity})`;
                ctx.lineWidth = 1;
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + 2, this.y + this.len);
                ctx.stroke();
            }
        }

        for (let i = 0; i < rainCount; i++) drops.push(new Drop());

        function drawRain() {
            ctx.clearRect(0, 0, w, h);
            drops.forEach(d => { d.update(); d.draw(); });
        }

        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            uniformsBG.iGlobalTime.value = time;

            renderer.render(sceneBG, cameraBG);
            // Render 3D scene (empty currently, but keeps light setup valid)
            // renderer.render(scene3D, camera3D); 
            drawRain();
        }
        animate();

        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            w = window.innerWidth;
            h = window.innerHeight;
            
            renderer.setSize(w, h);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0));
            
            uniformsBG.iResolution.value.set(w, h);
            
            canvas.width = w;
            canvas.height = h;
            
            // Re-initialize rain for new width
            drops.length = 0;
            const newCount = isMobile ? 100 : 300;
            for (let i = 0; i < newCount; i++) drops.push(new Drop());
        });

        // --- MUSIC PLAYER ---
        lucide.createIcons();
        const PLAYLIST = [{ title: "Glum - Knep list och långa fingrar", src: "Knep_List_och_Långa_Fingrar.mp3" }];
        
        let currentTrackIndex = 0;
        let isPlaying = false;
        let audio = new Audio(PLAYLIST[0].src);
        audio.volume = 0.5;

        // Unlock audio context for mobile
        function unlockMobile() {
            audio.play().then(() => { audio.pause(); }).catch(() => {});
            window.removeEventListener("pointerdown", unlockMobile);
            window.removeEventListener("touchstart", unlockMobile);
        }
        window.addEventListener("pointerdown", unlockMobile, { once: true });
        window.addEventListener("touchstart", unlockMobile, { once: true });

        const playBtn = document.getElementById('play-btn');
        const playIcon = document.getElementById('play-icon');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const trackTitle = document.getElementById('track-title');
        const progressBar = document.getElementById('progress-bar');
        const progressFill = document.getElementById('progress-fill');
        const volBar = document.getElementById('vol-bar');
        const volFill = document.getElementById('vol-fill');
        const muteBtn = document.getElementById('mute-btn');
        const volIcon = document.getElementById('vol-icon');

        trackTitle.innerText = PLAYLIST[0].title;

        function togglePlay() {
            if (audio.paused) {
                audio.play().catch(e => console.log(e));
                playIcon.setAttribute('data-lucide', 'pause');
            } else {
                audio.pause();
                playIcon.setAttribute('data-lucide', 'play');
            }
            lucide.createIcons();
            isPlaying = !audio.paused;
        }

        function loadTrack(index) {
            if (index < 0) index = PLAYLIST.length - 1;
            if (index >= PLAYLIST.length) index = 0;
            currentTrackIndex = index;
            audio.src = PLAYLIST[currentTrackIndex].src;
            trackTitle.innerText = PLAYLIST[currentTrackIndex].title;
            if (isPlaying) { audio.play(); playIcon.setAttribute('data-lucide', 'pause'); } 
            else { playIcon.setAttribute('data-lucide', 'play'); }
            lucide.createIcons();
        }

        function updateProgress() {
            if (audio.duration) {
                const percent = (audio.currentTime / audio.duration) * 100;
                progressBar.value = percent;
                progressFill.style.width = `${percent}%`;
            }
        }

        function seek(e) {
            const time = (e.target.value / 100) * audio.duration;
            audio.currentTime = time;
            progressFill.style.width = `${e.target.value}%`;
        }

        function updateVolume(e) {
            audio.volume = e.target.value;
            volFill.style.width = `${e.target.value * 100}%`;
            let icon = 'volume-2';
            if(audio.volume === 0) icon = 'volume-x';
            else if(audio.volume < 0.5) icon = 'volume-1';
            volIcon.setAttribute('data-lucide', icon);
            lucide.createIcons();
        }

        playBtn.addEventListener('click', togglePlay);
        nextBtn.addEventListener('click', () => loadTrack(currentTrackIndex + 1));
        prevBtn.addEventListener('click', () => loadTrack(currentTrackIndex - 1));
        audio.addEventListener('timeupdate', updateProgress);
        audio.addEventListener('ended', () => loadTrack(currentTrackIndex + 1));
        progressBar.addEventListener('input', seek);
        volBar.addEventListener('input', updateVolume);
        muteBtn.addEventListener('click', () => {
            if(audio.volume > 0) { audio.volume = 0; volBar.value = 0; updateVolume({target: {value: 0}}); }
            else { audio.volume = 0.5; volBar.value = 0.5; updateVolume({target: {value: 0.5}}); }
        });

    </script>
</body>
</html>
