<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TourBuddy - Immersive View</title>
    
    <!-- Load Tailwind CSS for the player styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* CRITICAL MOBILE FIX: Force 100dvh to handle mobile address bars correctly */
        html, body {
            width: 100%;
            height: 100dvh;
            margin: 0;
            overflow: hidden;
            background: #05070a; /* Fallback dark blue instead of black */
            touch-action: none; /* Prevents scroll rubber-banding on mobile */
        }
        
        /* LAYERING ORDER */
        #webgl-container { position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* Logo: Centered, behind rain/vignette */
        #logo-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Perfect center */
            z-index: 2; 
            width: 70vw;        /* Bigger */
            max-width: 900px; /* Allows it to grow */
            min-width: 300px; /* Optional */
            pointer-events: none; /* Clicks pass through */
            opacity: 0.9; /* Slight transparency for blending */
        }
        
        #logo-overlay img {
            width: 100%;
            height: auto;
            display: block;

            /* Radial fade mask: center opaque → edges transparent */
            mask-image: radial-gradient(circle,
                rgba(0,0,0,1) 40%,
                rgba(0,0,0,0) 100%
            );

            -webkit-mask-image: radial-gradient(circle,
                rgba(0,0,0,1) 40%,
                rgba(0,0,0,0) 100%
            );

            filter: drop-shadow(0 0 20px rgba(0,0,0,0.8)); 
        }

        #rain-canvas { 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 3; /* Rain is ON TOP of the logo */
            pointer-events: none; 
            mix-blend-mode: screen; 
            opacity: 0.4; 
        }
        
        /* --- VIGNETTE OVERLAY --- */
        #vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 4; /* On top of everything */
            pointer-events: none; 
            /* Changed to ELLIPSE to fit mobile screens better without crushing the sides */
            background: radial-gradient(ellipse at center, 
                rgba(0,0,0,0) 40%, 
                rgba(0,0,0,0.5) 80%, 
                rgba(0,0,0,0.9) 100%
            );
        }

        /* --- PLAYER STYLES --- */
        /* Custom Glass Effect matching the dark/orange theme */
        .glass-card {
            background: rgba(0, 0, 0, 0.3); /* High transparency */
            backdrop-filter: blur(8px);      /* Blur helps readability */
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.8);
        }
        
        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 12px;
            width: 12px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -4px; 
            box-shadow: 0 0 10px rgba(255,165,0,0.5); /* Orange glow */
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            border-radius: 999px;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="webgl-container"></div>
    
    <div id="logo-overlay">
        <!-- Placeholder for your logo -->
        <img src="Glum.png" onerror="this.style.display='none'" alt="Band Logo">
    </div>

    <canvas id="rain-canvas"></canvas>
    <div id="vignette"></div>

    <!-- --- MUSIC PLAYER UI --- -->
    <div id="music-player" class="fixed bottom-6 right-6 z-50 w-80 glass-card rounded-xl p-4 pointer-events-auto transition-opacity duration-500">
        <!-- Track Info -->
        <div class="flex items-center gap-3 mb-3">
            <div class="w-10 h-10 rounded bg-white/5 flex items-center justify-center text-orange-500 border border-white/10">
                <i data-lucide="music" class="w-5 h-5"></i>
            </div>
            <div class="flex-1 min-w-0">
                <div id="track-title" class="text-sm font-bold text-white truncate font-sans">
                    Loading...
                </div>
                <div class="text-[10px] text-orange-200/60 uppercase tracking-wider">
                    System Audio
                </div>
            </div>
        </div>

        <!-- Progress Bar -->
        <div class="mb-3 group relative">
            <input 
                type="range" 
                id="progress-bar"
                min="0" 
                max="100" 
                value="0" 
                class="w-full h-1 bg-white/10 rounded-lg appearance-none cursor-pointer"
            />
            <!-- Custom background div for the gradient fill -->
            <div id="progress-fill" class="absolute top-[6px] left-0 h-1 rounded-lg pointer-events-none bg-gradient-to-r from-orange-700 to-orange-500" style="width: 0%"></div>
        </div>

        <div class="flex items-center justify-between">
            <!-- Volume -->
            <div class="flex items-center gap-2 w-24">
                <button id="mute-btn" class="text-gray-400 hover:text-white transition-colors">
                    <i id="vol-icon" data-lucide="volume-2" class="w-4 h-4"></i>
                </button>
                <div class="relative w-full h-4 flex items-center">
                    <input 
                        type="range" 
                        id="vol-bar"
                        min="0" 
                        max="1" 
                        step="0.05" 
                        value="0.5" 
                        class="relative z-10 w-full h-1 bg-white/10 rounded-lg appearance-none cursor-pointer"
                    />
                    <div id="vol-fill" class="absolute left-0 h-1 rounded-lg pointer-events-none bg-gradient-to-r from-orange-700 to-orange-500" style="width: 50%"></div>
                </div>
            </div>

            <!-- Controls -->
            <div class="flex items-center gap-3">
                <button id="prev-btn" class="text-gray-400 hover:text-white transition-colors hover:scale-110 transform duration-200">
                    <i data-lucide="skip-back" class="w-5 h-5"></i>
                </button>
                
                <button id="play-btn" class="w-10 h-10 rounded-full bg-gradient-to-tr from-orange-700 to-orange-900 hover:from-orange-600 hover:to-orange-800 flex items-center justify-center text-white shadow-lg shadow-orange-900/40 transition-all hover:scale-110 hover:shadow-orange-500/20 border border-white/10">
                    <i id="play-icon" data-lucide="play" class="w-5 h-5 fill-current ml-0.5"></i>
                </button>
                
                <button id="next-btn" class="text-gray-400 hover:text-white transition-colors hover:scale-110 transform duration-200">
                    <i data-lucide="skip-forward" class="w-5 h-5"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- SHADERS -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = vec4(position, 1.0);
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        // CRITICAL FIX: Switched back to highp. 'mediump' causes black screens on ocean shaders.
        precision highp float;
        precision highp int;

        uniform float iGlobalTime;
        uniform vec2 iResolution;

        const int NUM_STEPS = 8;
        const float PI = 3.141592;
        const float EPSILON = 1e-3;
        // Adjusted epsilon calculation for shader compatibility
        #define EPSILON_NRM (0.1 / iResolution.x)

        // REDUCED ITERATIONS FOR MOBILE SAFETY
        const int ITER_GEOMETRY = 3;
        const int ITER_FRAGMENT = 4; // Reduced from 5 to 4 to prevent TDR timeouts
        
        const float SEA_HEIGHT = 0.6;
        const float SEA_CHOPPY = 4.0;
        const float SEA_SPEED = 0.8;
        const float SEA_FREQ = 0.16;
        const vec3 SEA_BASE = vec3(0.0, 0.01, 0.02); 
        const vec3 SEA_WATER_COLOR = vec3(0.1, 0.15, 0.25); 
        #define SEA_TIME (1.0 + iGlobalTime * SEA_SPEED)
        const mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);

        float hash( vec2 p ) {
            float h = dot(p,vec2(127.1,311.7));
            return fract(sin(h)*43758.5453123);
        }

        float noise( in vec2 p ) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            vec2 u = f*f*(3.0-2.0*f);
            return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), hash( i + vec2(1.0,0.0) ), u.x),
                                mix( hash( i + vec2(0.0,1.0) ), hash( i + vec2(1.0,1.0) ), u.x),
                                u.y);
        }

        float diffuse(vec3 n,vec3 l,float p) {
            return pow(max(dot(n,l) * 0.4 + 0.6, 0.0), p); // SAFE CLAMP
        }
        
        float specular(vec3 n,vec3 l,vec3 e,float s) {
            float nrm = (s + 8.0) / (PI * 8.0);
            return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;
        }

        vec3 getSkyColor(vec3 e) {
            e.y = max(e.y,0.0);
            vec3 darkSky = vec3(0.01, 0.01, 0.03);
            vec3 horizon = vec3(0.04, 0.06, 0.12); 
            return mix(horizon, darkSky, pow(e.y, 0.6));
        }

        float sea_octave(vec2 uv, float choppy) {
            uv += noise(uv);        
            vec2 wv = 1.0-abs(sin(uv));
            vec2 swv = abs(cos(uv));    
            wv = mix(wv,swv,wv);
            
            // --- CRITICAL MOBILE FIX: NaN GUARD ---
            // If wv.x*wv.y > 1.0 (due to float precision), 1.0-pow is negative.
            // pow(negative, choppy) = NaN (Black Screen).
            // We must Clamp inner value to >= 0.0
            return pow(max(1.0-pow(wv.x * wv.y,0.65), 0.0),choppy);
        }

        float map(vec3 p) {
            float freq = SEA_FREQ;
            float amp = SEA_HEIGHT;
            float choppy = SEA_CHOPPY;
            vec2 uv = p.xz; uv.x *= 0.75;
            
            float d, h = 0.0;    
            for(int i = 0; i < ITER_GEOMETRY; i++) {        
                d = sea_octave((uv+SEA_TIME)*freq,choppy);
                d += sea_octave((uv-SEA_TIME)*freq,choppy);
                h += d * amp;        
                uv *= octave_m; freq *= 1.9; amp *= 0.22;
                choppy = mix(choppy,1.0,0.2);
            }
            return p.y - h;
        }

        float map_detailed(vec3 p) {
            float freq = SEA_FREQ;
            float amp = SEA_HEIGHT;
            float choppy = SEA_CHOPPY;
            vec2 uv = p.xz; uv.x *= 0.75;
            
            float d, h = 0.0;    
            for(int i = 0; i < ITER_FRAGMENT; i++) {        
                d = sea_octave((uv+SEA_TIME)*freq,choppy);
                d += sea_octave((uv-SEA_TIME)*freq,choppy);
                h += d * amp;        
                uv *= octave_m; freq *= 1.9; amp *= 0.22;
                choppy = mix(choppy,1.0,0.2);
            }
            return p.y - h;
        }

        vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  
            float fresnel = 1.0 - max(dot(n,-eye),0.0);
            fresnel = pow(fresnel,3.0) * 0.5;
            
            vec3 reflected = getSkyColor(reflect(eye,n));    
            vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; 
            
            vec3 color = mix(refracted,reflected,fresnel);
            
            float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);
            color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;
            
            float spec = specular(n,l,eye,60.0);
            color += vec3(spec) * 0.5; 
            
            return color;
        }

        vec3 getNormal(vec3 p, float eps) {
            vec3 n;
            n.y = map_detailed(p);    
            n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;
            n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;
            n.y = eps;
            return normalize(n);
        }

        float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  
            float tm = 0.0;
            float tx = 1000.0;    
            float hx = map(ori + dir * tx);
            if(hx > 0.0) return tx;   
            float hm = map(ori + dir * tm);    
            float tmid = 0.0;
            for(int i = 0; i < NUM_STEPS; i++) {
                tmid = mix(tm,tx, hm/(hm-hx));                    
                p = ori + dir * tmid;                     
                float hmid = map(p);
                if(hmid < 0.0) {
                    tx = tmid;
                    hx = hmid;
                } else {
                    tm = tmid;
                    hm = hmid;
                }
            }
            return tmid;
        }

        void main() {
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            uv = uv * 2.0 - 1.0;
            
            // Calculate Aspect Ratio explicitly
            float aspect = iResolution.x / iResolution.y;
            uv.x *= aspect; 
            
            // --- MOBILE ZOOM & LIFT FIX ---
            // If aspect < 1.0 (Portrait Mode), the screen is tall.
            // We Zoom Out (uv * 2.5) to widen the FOV.
            // We Lift Camera (camHeight = 8.0) to look down from higher up.
            float camHeight = 3.5;
            
            if (aspect < 1.0) {
                uv *= 2.5;       // Stronger zoom out to show horizon
                camHeight = 8.0; // Lift camera higher to avoid "stuck in wave" look
            }

            float time = iGlobalTime * 0.3;
                
            vec3 ori = vec3(0.0, camHeight, time*5.0);
            vec3 dir = normalize(vec3(uv.xy, -2.0)); 
            dir.z += length(uv) * 0.15;
            dir = normalize(dir);
            
            vec3 p;
            heightMapTracing(ori,dir,p);
            vec3 dist = p - ori;
            vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);
            
            vec3 light = normalize(vec3(0.0, 1.0, 0.8)); 
            
            vec3 color = mix(
                getSkyColor(dir),
                getSeaColor(p,n,light,dir,dist),
                pow(smoothstep(0.0,-0.05,dir.y),0.3)
            );
            
            // --- CRITICAL MOBILE FIX: FINAL COLOR CLAMP ---
            // Ensure no negative colors before gamma correction
            color = max(color, 0.0);
            
            // Slightly brighter gamma for mobile (0.7 vs 0.8) to fight the darkness
            gl_FragColor = vec4(pow(color,vec3(0.7)), 1.0);
        }
    </script>

    <script>
        // --- 1. THREE.JS SCENE SETUP ---
        const container = document.getElementById('webgl-container');
        
        // CRITICAL FIX: Safe height function to handle mobile address bars
        const getMobileHeight = () => document.documentElement.clientHeight || window.innerHeight;

        // CRITICAL FIX: Mobile-optimized renderer settings
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: false,
            powerPreference: "high-performance",
            precision: "highp" // Changed to highp for quality
        });
        
        // CRITICAL FIX: Clamp Pixel Ratio to max 2.0 to prevent mobile overheat/crash
        const DPR = Math.min(window.devicePixelRatio, 2);
        renderer.setPixelRatio(DPR);
        
        // Use safe height
        renderer.setSize(window.innerWidth, getMobileHeight(), false);
        renderer.outputEncoding = THREE.sRGBEncoding;
        
        // CRITICAL FIX: Disable shadows for performance/stability on mobile
        renderer.shadowMap.enabled = false; 
        renderer.autoClear = false;
        
        container.appendChild(renderer.domElement);

        const sceneBG = new THREE.Scene();
        const cameraBG = new THREE.Camera();
        const geometryBG = new THREE.PlaneBufferGeometry(2, 2);
        const uniformsBG = {
            iGlobalTime: { value: 0 },
            iResolution: { value: new THREE.Vector2(window.innerWidth, getMobileHeight()) }
        };
        const materialBG = new THREE.ShaderMaterial({
            uniforms: uniformsBG,
            vertexShader: document.getElementById('vertex-shader').textContent,
            fragmentShader: document.getElementById('fragment-shader').textContent,
            depthWrite: false
        });
        sceneBG.add(new THREE.Mesh(geometryBG, materialBG));

        const scene3D = new THREE.Scene();
        scene3D.fog = new THREE.FogExp2(0x05070a, 0.035);

        const camera3D = new THREE.PerspectiveCamera(60, window.innerWidth/getMobileHeight(), 0.1, 1000);
        camera3D.position.set(0, -6.5, 6.0); 
        camera3D.lookAt(0, 0.5, -20);

        const moonLight = new THREE.DirectionalLight(0x667799, 0.25); 
        moonLight.position.set(-10, 20, -10);
        // Shadows disabled for mobile stability
        scene3D.add(moonLight);

        const lanternLight = new THREE.PointLight(0xff5500, 1.0, 20); 
        lanternLight.position.set(0, 5, 2);
        scene3D.add(lanternLight);

        const ambient = new THREE.AmbientLight(0x020205, 0.1); 
        scene3D.add(ambient);

        const canvas = document.getElementById('rain-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = getMobileHeight();

        const drops = [];
        const rainCount = 300;

        class Drop {
            constructor() { this.reset(); }
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * -canvas.height;
                this.speed = Math.random() * 10 + 15; 
                this.len = Math.random() * 15 + 10;
                this.opacity = Math.random() * 0.2 + 0.05;
            }
            update() {
                this.y += this.speed;
                if (this.y > canvas.height) this.reset();
            }
            draw() {
                ctx.beginPath();
                ctx.strokeStyle = `rgba(200, 210, 255, ${this.opacity})`;
                ctx.lineWidth = 1;
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + 2, this.y + this.len);
                ctx.stroke();
            }
        }

        for (let i = 0; i < rainCount; i++) drops.push(new Drop());

        function drawRain() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drops.forEach(d => { d.update(); d.draw(); });
        }

        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            uniformsBG.iGlobalTime.value = time;

            renderer.render(sceneBG, cameraBG);
            renderer.clearDepth();
            renderer.render(scene3D, camera3D);
            drawRain();
        }
        animate();

        // CRITICAL FIX: Correct mobile resize handling
        window.addEventListener('resize', () => {
            const w = window.innerWidth;
            const h = getMobileHeight();
            
            // Re-apply DPR clamp on resize (e.g. if user moves between monitors)
            const safeDPR = Math.min(window.devicePixelRatio, 2);
            renderer.setPixelRatio(safeDPR);
            
            renderer.setSize(w, h, false);
            uniformsBG.iResolution.value.set(w, h);
            
            camera3D.aspect = w / h;
            camera3D.updateProjectionMatrix();
            
            canvas.width = w;
            canvas.height = h;
        });

        // --- 2. MUSIC PLAYER INTEGRATION (VANILLA JS) ---
        
        // Initialize Lucide Icons
        lucide.createIcons();

        // Playlist Data
        const PLAYLIST = [
            { title: "Glum - Knep list och långa fingrar", src: "Knep_List_och_Långa_Fingrar.mp3" }
        ];

        // State Variables
        let currentTrackIndex = 0;
        let isPlaying = false;
        let volume = 0.5;
        let audio = new Audio(PLAYLIST[0].src);
        audio.volume = volume;

        // CRITICAL FIX: Mobile Auto-Play/Audio Context Unlock
        // This silently attempts to unlock audio on the first interaction
        function unlockMobile() {
            audio.play().then(() => {
                audio.pause();
            }).catch(() => {});
            window.removeEventListener("pointerdown", unlockMobile);
        }
        window.addEventListener("pointerdown", unlockMobile, { once: true });

        // DOM Elements
        const playBtn = document.getElementById('play-btn');
        const playIcon = document.getElementById('play-icon');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const trackTitle = document.getElementById('track-title');
        const progressBar = document.getElementById('progress-bar');
        const progressFill = document.getElementById('progress-fill');
        const volBar = document.getElementById('vol-bar');
        const volFill = document.getElementById('vol-fill');
        const muteBtn = document.getElementById('mute-btn');
        const volIcon = document.getElementById('vol-icon');

        // Initialize UI
        trackTitle.innerText = PLAYLIST[0].title;
        updateVolumeUI(volume);

        // --- Functions ---

        function togglePlay() {
            if (audio.paused) {
                audio.play().catch(e => console.error("Playback failed:", e));
                playIcon.setAttribute('data-lucide', 'pause');
            } else {
                audio.pause();
                playIcon.setAttribute('data-lucide', 'play');
            }
            // Need to refresh icons after attribute change
            lucide.createIcons();
            isPlaying = !audio.paused;
        }

        function loadTrack(index) {
            // Constrain index
            if (index < 0) index = PLAYLIST.length - 1;
            if (index >= PLAYLIST.length) index = 0;
            
            currentTrackIndex = index;
            audio.src = PLAYLIST[currentTrackIndex].src;
            trackTitle.innerText = PLAYLIST[currentTrackIndex].title;
            
            // Auto play if it was already playing
            if (isPlaying) {
                audio.play();
                playIcon.setAttribute('data-lucide', 'pause');
            } else {
                playIcon.setAttribute('data-lucide', 'play');
            }
            lucide.createIcons();
        }

        function updateProgress() {
            if (audio.duration) {
                const percent = (audio.currentTime / audio.duration) * 100;
                progressBar.value = percent;
                progressFill.style.width = `${percent}%`;
            }
        }

        function seek(e) {
            const percent = e.target.value;
            const time = (percent / 100) * audio.duration;
            audio.currentTime = time;
            progressFill.style.width = `${percent}%`;
        }

        function updateVolume(e) {
            const val = parseFloat(e.target.value);
            audio.volume = val;
            volume = val;
            updateVolumeUI(val);
        }

        function updateVolumeUI(val) {
            volBar.value = val;
            volFill.style.width = `${val * 100}%`;
            
            // Icon logic
            let iconName = 'volume-2';
            if (val === 0) iconName = 'volume-x';
            else if (val < 0.5) iconName = 'volume-1';
            
            volIcon.setAttribute('data-lucide', iconName);
            lucide.createIcons();
        }

        function toggleMute() {
            if (audio.volume > 0) {
                // Mute
                audio.volume = 0;
                updateVolumeUI(0);
            } else {
                // Unmute (restore prev volume or default)
                const newVol = volume || 0.5;
                audio.volume = newVol;
                updateVolumeUI(newVol);
            }
        }

        // --- Event Listeners ---

        playBtn.addEventListener('click', togglePlay);
        
        nextBtn.addEventListener('click', () => loadTrack(currentTrackIndex + 1));
        
        prevBtn.addEventListener('click', () => loadTrack(currentTrackIndex - 1));
        
        audio.addEventListener('timeupdate', updateProgress);
        
        audio.addEventListener('ended', () => loadTrack(currentTrackIndex + 1));
        
        progressBar.addEventListener('input', seek);
        
        volBar.addEventListener('input', updateVolume);
        
        muteBtn.addEventListener('click', toggleMute);

    </script>
</body>
</html>
