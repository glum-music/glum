<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Glum</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* CRITICAL MOBILE FIX */
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            overflow: hidden;
            background: #05070a; 
            touch-action: none;
        }
        
        #canvas-wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #webgl-container { 
            width: 100%; 
            height: 100%; 
        }
        
        /* LOGO */
        #logo-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2; 
            width: 70vw;
            max-width: 900px;
            pointer-events: none;
            opacity: 0.9;
        }

        /* --- ADD THIS BLOCK BELOW --- */
                @media (max-width: 768px) and (orientation: portrait) {
                    #logo-overlay {
                        top: 35%; /* 35% is higher up than the default 50% */
                    }
                }
        
        #logo-overlay img {
            width: 100%;
            height: auto;
            display: block;
            mask-image: radial-gradient(circle, rgba(0,0,0,1) 40%, rgba(0,0,0,0) 100%);
            -webkit-mask-image: radial-gradient(circle, rgba(0,0,0,1) 40%, rgba(0,0,0,0) 100%);
            filter: drop-shadow(0 0 20px rgba(0,0,0,0.8)); 
        }

        /* ATMOSPHERE LAYERS */
        #rain-canvas { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none; 
            mix-blend-mode: screen; 
            opacity: 0.4; 
        }
        
        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 4;
            pointer-events: none; 
            background: radial-gradient(circle, 
                rgba(0,0,0,0) 40%, 
                rgba(0,0,0,0.6) 80%, 
                rgba(0,0,0,0.95) 100%
            );
        }

        .cold-card {
            background: rgba(5, 5, 5, 0.02);    /* Much more transparent (was 0.85) */
    
            /* These stay the same to keep the border and shadow defined */
            border: 0px solid rgba(255, 255, 255, 0);
            box-shadow: 0 0px 0px 0 rgba(0, 0, 0, 1.0);
        }

        /* Custom Scrollbar for playlist */
        .custom-scroll::-webkit-scrollbar {
            width: 4px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.02); 
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2); 
        }
        .custom-scroll::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.4); 
        }
        
        /* Range Sliders - Monochrome Style */
        input[type=range] {
            -webkit-appearance: none;
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 10px;
            width: 10px;
            background: #d4d4d8; /* Zinc-300 */
            cursor: pointer;
            margin-top: -4px; 
            border: 1px solid black;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: rgba(255,255,255,0.1);
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="canvas-wrapper">
        <div id="webgl-container"></div>
    </div>
    
    <div id="logo-overlay">
        <img src="Glum.png" onerror="this.style.display='none'" alt="Band Logo">
    </div>

    <canvas id="rain-canvas"></canvas>
    <div id="vignette"></div>

    <div id="music-player" class="fixed bottom-6 right-6 z-50 w-96 max-w-[90vw] cold-card rounded-sm p-5 pointer-events-auto transition-opacity duration-500 flex flex-col gap-4">
        
        <div class="flex items-start justify-between border-b border-white/5 pb-4">
            <div class="flex-1 min-w-0 pr-4">
                <div class="text-[10px] text-zinc-500 uppercase tracking-[0.2em] mb-1">spelar</div>
                <div id="track-title" class="text-sm font-bold text-zinc-200 truncate font-sans tracking-wide">
                    Loading...
                </div>
            </div>
            <div class="w-8 h-8 flex items-center justify-center text-zinc-400">
                <i data-lucide="music" class="w-4 h-4 opacity-50"></i>
            </div>
        </div>

        <div>
            <div class="mb-4 group relative">
                <input 
                    type="range" 
                    id="progress-bar"
                    min="0" 
                    max="100" 
                    value="0" 
                    class="w-full h-1 appearance-none cursor-pointer z-20 relative"
                />
                <div id="progress-fill" class="absolute top-[6px] left-0 h-[2px] pointer-events-none bg-zinc-300" style="width: 0%"></div>
            </div>

            <div class="flex items-center justify-between">
                <div class="flex items-center gap-2 w-20 group">
                    <button id="mute-btn" class="text-zinc-600 hover:text-zinc-300 transition-colors">
                        <i id="vol-icon" data-lucide="volume-2" class="w-4 h-4"></i>
                    </button>
                    <div class="relative w-full h-4 flex items-center">
                        <input 
                            type="range" 
                            id="vol-bar"
                            min="0" 
                            max="1" 
                            step="0.05" 
                            value="0.5" 
                            class="relative z-10 w-full h-1 appearance-none cursor-pointer"
                        />
                        <div id="vol-fill" class="absolute left-0 h-[2px] rounded-lg pointer-events-none bg-zinc-400" style="width: 50%"></div>
                    </div>
                </div>

                <div class="flex items-center gap-4">
                    <button id="prev-btn" class="text-zinc-500 hover:text-zinc-100 transition-colors transform hover:-translate-x-0.5 duration-200">
                        <i data-lucide="skip-back" class="w-5 h-5"></i>
                    </button>
                    
                    <button id="play-btn" class="w-10 h-10 border border-zinc-600 hover:border-zinc-300 hover:bg-zinc-900 rounded-full flex items-center justify-center text-zinc-100 transition-all duration-300">
                        <i id="play-icon" data-lucide="play" class="w-4 h-4 fill-current ml-0.5"></i>
                    </button>
                    
                    <button id="next-btn" class="text-zinc-500 hover:text-zinc-100 transition-colors transform hover:translate-x-0.5 duration-200">
                        <i data-lucide="skip-forward" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>
        </div>

        <div class="border-t border-white/5 pt-2">
            <div class="text-[10px] text-zinc-600 uppercase tracking-widest mb-2 px-1">Låtar</div>
            <div id="playlist-container" class="max-h-32 overflow-y-auto custom-scroll flex flex-col gap-1 pr-1">
                </div>
        </div>
    </div>

    <script id="vertex-shader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = vec4(position, 1.0);
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_FRAGMENT_PRECISION_HIGH
            precision highp float;
        #else
            precision mediump float;
        #endif

        uniform float iGlobalTime;
        uniform vec2 iResolution;

        const float PI = 3.141592;
        #define EPSILON_NRM (0.1 / iResolution.x)

        #ifdef IS_MOBILE
            const int NUM_STEPS = 6;        
            const int ITER_GEOMETRY = 3;    
            const int ITER_FRAGMENT = 4;    
        #else
            const int NUM_STEPS = 8;
            const int ITER_GEOMETRY = 3;
            const int ITER_FRAGMENT = 5;
        #endif
        
        const float SEA_HEIGHT = 0.6;
        const float SEA_CHOPPY = 4.0;
        const float SEA_SPEED = 0.8;
        const float SEA_FREQ = 0.16;
        const vec3 SEA_BASE = vec3(0.0, 0.01, 0.02); 
        const vec3 SEA_WATER_COLOR = vec3(0.1, 0.15, 0.25); 
        #define SEA_TIME (1.0 + iGlobalTime * SEA_SPEED)
        const mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);

        float hash( vec2 p ) {
            float h = dot(p,vec2(127.1,311.7));
            return fract(sin(h)*43758.5453123);
        }

        float noise( in vec2 p ) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            vec2 u = f*f*(3.0-2.0*f);
            return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), hash( i + vec2(1.0,0.0) ), u.x),
                                mix( hash( i + vec2(0.0,1.0) ), hash( i + vec2(1.0,1.0) ), u.x),
                                u.y);
        }

        float diffuse(vec3 n,vec3 l,float p) {
            return pow(max(dot(n,l) * 0.4 + 0.6, 0.0), p);
        }
        
        float specular(vec3 n,vec3 l,vec3 e,float s) {
            float nrm = (s + 8.0) / (PI * 8.0);
            return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;
        }

        vec3 getSkyColor(vec3 e) {
            e.y = max(e.y,0.001); 
            vec3 darkSky = vec3(0.01, 0.01, 0.03);
            vec3 horizon = vec3(0.04, 0.06, 0.12); 
            return mix(horizon, darkSky, pow(e.y, 0.6));
        }

        float sea_octave(vec2 uv, float choppy) {
            uv += noise(uv);        
            vec2 wv = 1.0-abs(sin(uv));
            vec2 swv = abs(cos(uv));    
            wv = mix(wv,swv,wv);
            return pow(max(1.0 - pow(wv.x * wv.y, 0.65), 0.0), choppy);
        }

        float map(vec3 p) {
            float freq = SEA_FREQ;
            float amp = SEA_HEIGHT;
            float choppy = SEA_CHOPPY;
            vec2 uv = p.xz; uv.x *= 0.75;
            
            float d, h = 0.0;     
            for(int i = 0; i < ITER_GEOMETRY; i++) {        
                d = sea_octave((uv+SEA_TIME)*freq,choppy);
                d += sea_octave((uv-SEA_TIME)*freq,choppy);
                h += d * amp;        
                uv *= octave_m; freq *= 1.9; amp *= 0.22;
                choppy = mix(choppy,1.0,0.2);
            }
            return p.y - h;
        }

        float map_detailed(vec3 p) {
            float freq = SEA_FREQ;
            float amp = SEA_HEIGHT;
            float choppy = SEA_CHOPPY;
            vec2 uv = p.xz; uv.x *= 0.75;
            
            float d, h = 0.0;     
            for(int i = 0; i < ITER_FRAGMENT; i++) {        
                d = sea_octave((uv+SEA_TIME)*freq,choppy);
                d += sea_octave((uv-SEA_TIME)*freq,choppy);
                h += d * amp;        
                uv *= octave_m; freq *= 1.9; amp *= 0.22;
                choppy = mix(choppy,1.0,0.2);
            }
            return p.y - h;
        }

        vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  
            float fresnel = 1.0 - max(dot(n,-eye),0.0);
            fresnel = pow(fresnel,3.0) * 0.5;
            
            vec3 reflected = getSkyColor(reflect(eye,n));    
            vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; 
            
            vec3 color = mix(refracted,reflected,fresnel);
            
            float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);
            color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;
            
            float spec = specular(n,l,eye,60.0);
            color += vec3(spec) * 0.5; 
            
            return color;
        }

        vec3 getNormal(vec3 p, float eps) {
            vec3 n;
            n.y = map_detailed(p);    
            n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;
            n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;
            n.y = eps;
            return normalize(n);
        }

        float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  
            float tm = 0.0;
            float tx = 1000.0;    
            float hx = map(ori + dir * tx);
            if(hx > 0.0) return tx;   
            float hm = map(ori + dir * tm);    
            float tmid = 0.0;
            for(int i = 0; i < NUM_STEPS; i++) {
                tmid = mix(tm,tx, hm/(hm-hx));                    
                p = ori + dir * tmid;                     
                float hmid = map(p);
                if(hmid < 0.0) {
                    tx = tmid;
                    hx = hmid;
                } else {
                    tm = tmid;
                    hm = hmid;
                }
            }
            return tmid;
        }

        void main() {
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            uv = uv * 2.0 - 1.0;
            
            float aspect = iResolution.x / iResolution.y;
            uv.x *= aspect; 
            
            #ifdef IS_MOBILE
                uv.y -= 1.1; 
            #endif

            float camHeight = 3.5;
            float time = iGlobalTime * 0.3;
                
            vec3 ori = vec3(0.0, camHeight, time*5.0);
            vec3 dir = normalize(vec3(uv.xy, -2.0)); 
            dir.z += length(uv) * 0.15;
            dir = normalize(dir);
            
            vec3 p;
            heightMapTracing(ori,dir,p);
            vec3 dist = p - ori;
            vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);
            
            vec3 light = normalize(vec3(0.0, 1.0, 0.8)); 
            
            vec3 color = mix(
                getSkyColor(dir),
                getSeaColor(p,n,light,dir,dist),
                pow(smoothstep(0.0,-0.05,dir.y),0.3)
            );
            
            color = max(color, 0.0);
            
            gl_FragColor = vec4(pow(color,vec3(0.8)), 1.0);
        }
    </script>

    <script>
        // --- DETECT MOBILE ---
        const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
        console.log("Is Mobile Mode:", isMobile);

        const container = document.getElementById('webgl-container');
        
        // --- THREE.JS SETUP ---
        const renderer = new THREE.WebGLRenderer({ 
            antialias: !isMobile, 
            alpha: false,
            powerPreference: "high-performance"
        });
        
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = false; 
        renderer.autoClear = false;
        container.appendChild(renderer.domElement);

        const sceneBG = new THREE.Scene();
        const cameraBG = new THREE.Camera();
        const geometryBG = new THREE.PlaneBufferGeometry(2, 2);
        
        const uniformsBG = {
            iGlobalTime: { value: 0 },
            iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
        };

        let fragCode = document.getElementById('fragment-shader').textContent;
        if(isMobile) {
            fragCode = "#define IS_MOBILE\n" + fragCode;
        }

        const materialBG = new THREE.ShaderMaterial({
            uniforms: uniformsBG,
            vertexShader: document.getElementById('vertex-shader').textContent,
            fragmentShader: fragCode,
            depthWrite: false
        });
        sceneBG.add(new THREE.Mesh(geometryBG, materialBG));

        // --- RAIN CANVAS ---
        const canvas = document.getElementById('rain-canvas');
        const ctx = canvas.getContext('2d');
        
        let w = window.innerWidth;
        let h = window.innerHeight;
        canvas.width = w;
        canvas.height = h;

        const drops = [];
        const rainCount = isMobile ? 100 : 300; 

        class Drop {
            constructor() { this.reset(); }
            reset() {
                this.x = Math.random() * w;
                this.y = Math.random() * -h;
                this.speed = Math.random() * 10 + 15; 
                this.len = Math.random() * 15 + 10;
                this.opacity = Math.random() * 0.2 + 0.05;
            }
            update() {
                this.y += this.speed;
                if (this.y > h) this.reset();
            }
            draw() {
                ctx.beginPath();
                ctx.strokeStyle = `rgba(200, 210, 255, ${this.opacity})`;
                ctx.lineWidth = 1;
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + 2, this.y + this.len);
                ctx.stroke();
            }
        }

        for (let i = 0; i < rainCount; i++) drops.push(new Drop());

        function drawRain() {
            ctx.clearRect(0, 0, w, h);
            drops.forEach(d => { d.update(); d.draw(); });
        }

        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            uniformsBG.iGlobalTime.value = time;

            renderer.render(sceneBG, cameraBG);
            drawRain();
        }
        animate();

        window.addEventListener('resize', () => {
            w = window.innerWidth;
            h = window.innerHeight;
            renderer.setSize(w, h);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0));
            uniformsBG.iResolution.value.set(w, h);
            canvas.width = w;
            canvas.height = h;
            drops.length = 0;
            const newCount = isMobile ? 100 : 300;
            for (let i = 0; i < newCount; i++) drops.push(new Drop());
        });

        // --- MUSIC PLAYER ---
        lucide.createIcons();
        
        // ADDED DUMMY TRACKS TO DEMONSTRATE LIST
        const PLAYLIST = [
            { title: "Knep list och långa fingrar", src: "Knep_List_och_Långa_Fingrar.mp3" },
            { title: "Låt 2", src: "#" }, 
            { title: "Låt 3", src: "#" },
            { title: "Lår 4", src: "#" }
        ];
        
        let currentTrackIndex = 0;
        let isPlaying = false;
        let audio = new Audio(PLAYLIST[0].src);
        audio.volume = 0.5;

        function unlockMobile() {
            audio.play().then(() => { audio.pause(); }).catch(() => {});
            window.removeEventListener("pointerdown", unlockMobile);
            window.removeEventListener("touchstart", unlockMobile);
        }
        window.addEventListener("pointerdown", unlockMobile, { once: true });
        window.addEventListener("touchstart", unlockMobile, { once: true });

        const playBtn = document.getElementById('play-btn');
        const playIcon = document.getElementById('play-icon');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const trackTitle = document.getElementById('track-title');
        const progressBar = document.getElementById('progress-bar');
        const progressFill = document.getElementById('progress-fill');
        const volBar = document.getElementById('vol-bar');
        const volFill = document.getElementById('vol-fill');
        const muteBtn = document.getElementById('mute-btn');
        const volIcon = document.getElementById('vol-icon');
        const playlistContainer = document.getElementById('playlist-container');

        // Render Initial Playlist
        function renderPlaylist() {
            playlistContainer.innerHTML = '';
            PLAYLIST.forEach((track, index) => {
                const item = document.createElement('div');
                item.className = `cursor-pointer p-2 text-xs truncate transition-colors duration-200 border-l-2 ${
                    index === currentTrackIndex 
                    ? 'border-zinc-100 bg-white/10 text-zinc-100 font-bold' 
                    : 'border-transparent text-zinc-500 hover:text-zinc-300 hover:bg-white/5'
                }`;
                item.innerText = `${index + 1}. ${track.title}`;
                item.onclick = () => loadTrack(index);
                playlistContainer.appendChild(item);
            });
        }

        trackTitle.innerText = PLAYLIST[0].title;
        renderPlaylist();

        function togglePlay() {
            if (audio.paused) {
                audio.play().catch(e => console.log(e));
                playIcon.setAttribute('data-lucide', 'pause');
            } else {
                audio.pause();
                playIcon.setAttribute('data-lucide', 'play');
            }
            lucide.createIcons();
            isPlaying = !audio.paused;
        }

        function loadTrack(index) {
            if (index < 0) index = PLAYLIST.length - 1;
            if (index >= PLAYLIST.length) index = 0;
            currentTrackIndex = index;
            
            audio.src = PLAYLIST[currentTrackIndex].src;
            trackTitle.innerText = PLAYLIST[currentTrackIndex].title;
            
            if (isPlaying) { 
                audio.play(); 
                playIcon.setAttribute('data-lucide', 'pause'); 
            } else { 
                playIcon.setAttribute('data-lucide', 'play'); 
            }
            
            renderPlaylist(); // Update the list highlighting
            lucide.createIcons();
        }

        function updateProgress() {
            if (audio.duration) {
                const percent = (audio.currentTime / audio.duration) * 100;
                progressBar.value = percent;
                progressFill.style.width = `${percent}%`;
            }
        }

        function seek(e) {
            const time = (e.target.value / 100) * audio.duration;
            audio.currentTime = time;
            progressFill.style.width = `${e.target.value}%`;
        }

        function updateVolume(e) {
            audio.volume = e.target.value;
            volFill.style.width = `${e.target.value * 100}%`;
            let icon = 'volume-2';
            if(audio.volume === 0) icon = 'volume-x';
            else if(audio.volume < 0.5) icon = 'volume-1';
            volIcon.setAttribute('data-lucide', icon);
            lucide.createIcons();
        }

        playBtn.addEventListener('click', togglePlay);
        nextBtn.addEventListener('click', () => loadTrack(currentTrackIndex + 1));
        prevBtn.addEventListener('click', () => loadTrack(currentTrackIndex - 1));
        audio.addEventListener('timeupdate', updateProgress);
        audio.addEventListener('ended', () => loadTrack(currentTrackIndex + 1));
        progressBar.addEventListener('input', seek);
        volBar.addEventListener('input', updateVolume);
        muteBtn.addEventListener('click', () => {
            if(audio.volume > 0) { audio.volume = 0; volBar.value = 0; updateVolume({target: {value: 0}}); }
            else { audio.volume = 0.5; volBar.value = 0.5; updateVolume({target: {value: 0.5}}); }
        });

    </script>
</body>
</html>
